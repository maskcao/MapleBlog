<!-- Customized from https://github.com/heidkaemper/tailwindcss-intersect -->

<script is:inline>
  const Observer = {
    observer: null,
    delayBetweenAnimations: 100, // ms
    animationCounter: 0,

    start() {
      // 优化：合并选择器，减少DOM查询次数
      const selector = '[class*="intersect"]';
      const elements = Array.from(document.querySelectorAll(selector));

      const getThreshold = (element) => {
        if (element.classList.contains("intersect-full")) {
          return 0.99;
        } else if (element.classList.contains("intersect-half")) {
          return 0.5;
        } else if (element.classList.contains("intersect-quarter")) {
          return 0.25;
        } else {
          return 0.25;
        }
      };

      elements.forEach((el) => {
        el.setAttribute("no-intersect", "");
        el._intersectionThreshold = getThreshold(el);
      });

      // 优化：批量处理DOM更新，减少重排重绘
      const callback = (entries) => {
        const updates = [];
        
        entries.forEach((entry) => {
          const target = entry.target;
          const intersectionRatio = entry.intersectionRatio;
          const threshold = target._intersectionThreshold;

          if (target.classList.contains("intersect-no-queue")) {
            if (entry.isIntersecting) {
              updates.push(() => {
                target.removeAttribute("no-intersect");
                if (!target.classList.contains("intersect-repeat")) {
                  this.observer.unobserve(target);
                }
              });
            } else {
              updates.push(() => target.setAttribute("no-intersect", ""));
            }
            return;
          }

          if (intersectionRatio >= threshold) {
            if (!target.hasAttribute("data-animated")) {
              updates.push(() => {
                target.removeAttribute("no-intersect");
                target.setAttribute("data-animated", "true");

                const delay = this.animationCounter * this.delayBetweenAnimations;
                this.animationCounter++;

                target.style.animationDelay = `${delay}ms`;

                if (!target.classList.contains("intersect-repeat")) {
                  this.observer.unobserve(target);
                }
              });
            }
          } else {
            updates.push(() => {
              target.setAttribute("no-intersect", "");
              target.removeAttribute("data-animated");
              target.style.transitionDelay = "";
              target.style.animationDelay = "";
              this.animationCounter = 0;
            });
          }
        });

        // 优化：单次requestAnimationFrame批量执行所有DOM更新
        if (updates.length > 0) {
          requestAnimationFrame(() => {
            updates.forEach(update => update());
          });
        }
      };

      this.observer = new IntersectionObserver(callback.bind(this), {
        threshold: [0, 0.25, 0.5, 0.99],
      });

      elements.forEach((el) => {
        this.observer.observe(el);
      });
    },
  };

  Observer.start();

  document.addEventListener("astro:after-swap", () => {
    Observer.start();
  });
</script>
